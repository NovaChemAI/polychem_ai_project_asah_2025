# -*- coding: utf-8 -*-
"""Polychem_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IBfzseIefJsAwU7sggxj1tQFYhid5CPj
"""

!pip install -q --upgrade langchain google-generativeai==0.8.5 langchain-google-genai google-api-core rdkit #install library package

from langchain_google_genai import ChatGoogleGenerativeAI #import google gen AI
from rdkit import Chem, DataStructs
from rdkit import RDLogger
from rdkit.Chem import AllChem, Draw
from rdkit.Chem.Draw import rdMolDraw2D
import os
import re
import pandas as pd
import json
import logging
import numpy as np
from IPython.display import Image, display
import io
from PIL import Image as PILImage
logging.getLogger().setLevel(logging.ERROR)
RDLogger.DisableLog('rdApp.*')

id_data = '13L5ZFx_vZyrTwS4tUeWADO1-SE_oPHkM'
load_url = f'https://drive.google.com/uc?id={id_data}'
df = pd.read_csv(load_url)
df.head(20)

os.environ["GOOGLE_API_KEY"] = "AIzaSyDgcPbMWYYkyj4pkyQX474LcuDhU5w_iNU"
llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0.7)

def add_dataset_properties_instant():
    """Enrich dataset INSTANT tanpa LLM - hanya RDKit."""
    global df


    for col in ['Name', 'MolecularWeight', 'Formula']:
        if col not in df.columns:
            df[col] = ''

    for idx, row in df.iterrows():
        smiles = row['SMILES']
        mol = Chem.MolFromSmiles(smiles)

        if mol is not None:

            formula = Chem.rdMolDescriptors.CalcMolFormula(mol)
            mw = Chem.rdMolDescriptors.CalcExactMolWt(mol)

            df.at[idx, 'Formula'] = formula
            df.at[idx, 'MolecularWeight'] = round(mw, 2)

            name = generate_instant_name(mol, smiles, idx)
            df.at[idx, 'Name'] = name

    print(df[['SMILES', 'Tg', 'Name', 'Formula', 'MolecularWeight']].head())
    return df

def generate_instant_name(mol, smiles, idx):
    """Generate nama instant berdasarkan functional groups."""
    try:
        # Functional group patterns
        if Chem.MolToSmiles(mol).count('P') > 0:
            return "Phosphazene derivative"
        elif Chem.MolToSmiles(mol).count('N') >= 2:
            return "Polyamine compound"
        elif Chem.MolToSmiles(mol).count('O') >= 4:
            return "Polyether molecule"
        elif smiles.count('C=O') > 0:
            return "Carbonyl compound"
        else:
            return f"Organic_{idx}"
    except:
        return f"Compound_{idx}"

add_dataset_properties_instant()

# TOOLS
def smiles_to_image(smiles: str, image_size=(800, 300),
    bondLineWidth=7,
    includeAtomNumbers=False) -> PILImage.Image:
    """Generate gambar 2D dengan kontrol lengkap."""
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None

        AllChem.Compute2DCoords(mol)

        drawer = rdMolDraw2D.MolDraw2DCairo(image_size[0], image_size[1])
        drawer.drawOptions().bondLineWidth = bondLineWidth
        drawer.drawOptions().addAtomIndices = includeAtomNumbers
        drawer.DrawMolecule(mol)
        drawer.FinishDrawing()

        return PILImage.open(io.BytesIO(drawer.GetDrawingText()))
    except Exception as e:
        print(f"Error: {e}")
        return None

def display_smiles_with_image(smiles: str, title: str):
    """Display nama SMILES dan gambarnya di bawah."""
    print(f"\n{title}")
    print("-" * 80)

    img = smiles_to_image(smiles)
    if img:
        display(img)
        print(f"SMILES: {smiles}")
    else:
        print(f"Gagal generate gambar untuk SMILES: {smiles}")
    print()


def generate_compound_name(smiles: str) -> str:
    """Generate nama senyawa baru berdasarkan SMILES."""
    prompt = f"""Buat nama senyawa kimia baru yang belum teridentifikasi untuk SMILES ini: {smiles}

Nama harus:
1. Unik dan belum ada di dunia
2. Mengikuti konvensi IUPAC (jika memungkinkan)
3. Menarik dan mudah diingat
4. Maksimal 50 karakter

Hanya berikan nama, tanpa penjelasan tambahan."""

    response = llm.invoke(prompt)
    return response.content.strip()

def generate_chemical_formula_and_tg(smiles: str, compound_name: str) -> dict:
    """
    Generate formula kimia dasar dan Glass Transition Temperature (Tg) prediksi
    untuk senyawa baru berdasarkan SMILES dan nama senyawa.

    Returns:
        dict: {
            'formula': 'C10H12N2O',
            'molecular_weight': 176.22,
            'predicted_tg': 125.5,  # °C
            'tg_justification': 'str'
        }
    """
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return {"error": "SMILES tidak valid"}

        # Hitung formula kimia dasar dan molecular weight
        formula = Chem.rdMolDescriptors.CalcMolFormula(mol)
        mw = Chem.rdMolDescriptors.CalcExactMolWt(mol)

        # Generate Tg prediksi + justifikasi menggunakan LLM
        prompt = f"""SMILES: {smiles}
Nama senyawa: {compound_name}
Formula kimia: {formula}
Berat molekul: {mw:.2f} g/mol

Prediksi Glass Transition Temperature (Tg) untuk senyawa polimer ini:

1. Berikan nilai Tg dalam °C (rentang realistis: -100°C sampai +300°C)
2. Justifikasi singkat (1-2 kalimat Bahasa Indonesia) berdasarkan:
   - Struktur molekul (rigiditas, rantai samping, interaksi H-bond)
   - Berat molekul
   - Karakteristik kimia (aromatik, polaritas, sterik)

Format JSON:
{{
  "predicted_tg": 125.5,
  "tg_justification": "Tg tinggi karena cincin aromatik memberikan rigiditas..."
}}

Hanya JSON, tanpa teks tambahan."""

        response = llm.invoke(prompt)

        # Parse JSON response
        try:
            tg_data = json.loads(response.content.strip())
        except:
            # Fallback jika JSON parsing gagal
            tg_data = {"predicted_tg": 100.0, "tg_justification": "Prediksi berdasarkan struktur umum"}

        return {
            "formula": formula,
            "molecular_weight": round(mw, 2),
            "predicted_tg": round(tg_data["predicted_tg"], 1),
            "tg_justification": tg_data["tg_justification"]
        }

    except Exception as e:
        return {"error": str(e)}


def generate_fingerprint_justification(smiles: str, compound_name: str) -> tuple:
    """Generate fingerprint dan justifikasi untuk senyawa."""
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None, "Error: SMILES tidak valid"

        # Generate fingerprint Morgan
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
        fp_list = list(fp)

        # Generate justifikasi menggunakan LLM
        prompt = f"""Berdasarkan struktur SMILES: {smiles}
Nama senyawa: {compound_name}

Berikan justifikasi singkat (2-3 kalimat dalam Bahasa Indonesia) mengapa senyawa ini unik dan belum teridentifikasi.
Pertimbangkan: struktur molekul, potensi aplikasi, dan keunikan karakteristik kimia.

Hanya berikan justifikasi tanpa nomor atau penjelasan tambahan."""

        response = llm.invoke(prompt)
        justifikasi = response.content.strip()

        return fp_list, justifikasi
    except Exception as e:
        return None, str(e)


def find_similar_compounds(smiles: str, compound_name: str) -> list:
    """Cari 3 senyawa paling mirip dari dataset menggunakan Tanimoto similarity."""
    try:
        # Generate fingerprint untuk senyawa input
        mol_input = Chem.MolFromSmiles(smiles)
        if mol_input is None:
            return []

        input_fp = AllChem.GetMorganFingerprintAsBitVect(mol_input, 2, nBits=2048)


        dataset_fingerprints = []
        valid_indices = []

        for idx, row in df.iterrows():
            try:
                mol = Chem.MolFromSmiles(row['SMILES'])
                if mol is not None:
                    fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
                    dataset_fingerprints.append(fp)
                    valid_indices.append(idx)
            except:
                continue

        if not dataset_fingerprints:
            return []

        # Hitung Tanimoto similarity
        similarities = []
        for fp in dataset_fingerprints:
            sim = DataStructs.TanimotoSimilarity(input_fp, fp) * 100
            similarities.append(sim)

        # Ambil 3 teratas
        top_indices = np.argsort(similarities)[::-1][:3]

        similar_compounds = []
        for i, top_idx in enumerate(top_indices):
            data_idx = valid_indices[top_idx]
            row = df.iloc[data_idx]

            # Generate justifikasi untuk compound mirip
            justify_prompt = f"""Target compound: {compound_name}
Dataset compound SMILES: {row['SMILES']}

Beri justifikasi singkat (2-3 kalimat Bahasa Indonesia) mengapa compound ini mirip dengan target.
Hanya berikan justifikasi tanpa penjelasan tambahan."""

            justify_response = llm.invoke(justify_prompt)

            similar_compounds.append({
                "rank": i + 1,
                "smiles": row['SMILES'],
                "tg": row.get('Tg', 'N/A'),
                "name": row.get('Name', 'N/A'),
                "formula": row.get('Formula', 'N/A'),
                "molecular_weight": row.get('MolecularWeight', 'N/A'),
                "similarity_score": float(similarities[top_idx]),
                "justifikasi": justify_response.content.strip()
            })

        return similar_compounds
    except Exception as e:
        print(f"Error in find_similar_compounds: {e}")
        return []

def recommend_new_compound(input_smiles: str) -> dict:
    """
    Orchestrator untuk merekomendasikan senyawa kimia baru.

    Workflow:
    1. Validasi SMILES
    2. Generate nama senyawa baru
    3. Generate fingerprint dan justifikasi
    4. Cari 3 senyawa mirip dari dataset
    5. Return hasil lengkap
    """

    # Validasi SMILES
    mol = Chem.MolFromSmiles(input_smiles)
    if mol is None:
        return {"error": "SMILES tidak valid", "input": input_smiles}

    compound_name = generate_compound_name(input_smiles)
    formula_tg_result = generate_chemical_formula_and_tg(input_smiles, compound_name)
    fingerprint, justifikasi = generate_fingerprint_justification(input_smiles, compound_name)

    if fingerprint is None:
        return {"error": justifikasi}

    similar_compounds = find_similar_compounds(input_smiles, compound_name)


    # Compile hasil
    result = {
            "status": "success",
            "input_smiles": input_smiles,
            "new_compound": {
                "name": compound_name or "N/A",
                "smiles": input_smiles,
                "formula": formula_tg_result.get("formula", "N/A"),
                "molecular_weight": formula_tg_result.get("molecular_weight", "N/A"),
                "predicted_tg": formula_tg_result.get("predicted_tg", "N/A"),
                "tg_justification": formula_tg_result.get("tg_justification", ""),
                "justifikasi": justifikasi if justifikasi else "",
                "fingerprint_length": len(fingerprint) if fingerprint else 0
            },
            "similar_compounds": similar_compounds or []
        }

    return result

def display_results(result: dict):
    """Display hasil rekomendasi dengan gambar untuk setiap SMILES."""

    if "error" in result:
        print(f"\n Error: {result['error']}")
        return

    print("\n" + "="*90)
    print("HASIL REKOMENDASI SENYAWA KIMIA BARU")
    print("="*90)

    new_compound = result["new_compound"]

    # Display senyawa baru dengan gambar
    display_smiles_with_image(
        new_compound['smiles'],
        "GENERATE SENYAWA BARU"
    )
    print(f"Nama Senyawa      : {new_compound['name']}")
    print(f"Formula Kimia     : {new_compound.get('formula', 'N/A')}")
    print(f"Berat Molekul     : {new_compound.get('molecular_weight', 'N/A')} g/mol")
    print(f"Tg Prediksi       : {new_compound.get('predicted_tg', 'N/A')} °C")
    print(f"Justifikasi Tg    : {new_compound.get('tg_justification', 'N/A')}")
    print(f"Justifikasi Umum  : {new_compound['justifikasi']}")
    print(f"Fingerprint Bits  : {new_compound['fingerprint_length']}")

    # Display senyawa mirip dengan gambar
    print(f"\n\nSENYAWA YANG MIRIP")
    print("-" * 90)

    for compound in result["similar_compounds"]:
       display_smiles_with_image(
            compound['smiles'],
            f"#{compound['rank']} Senyawa kimia"
        )
       print(f"Nama Senyawa    : {compound['name']}")
       print(f"Formula Kimia   : {compound['formula']}")
       print(f"Berat Molekul   : {compound['molecular_weight']} g/mol")
       print(f"Tg              : {compound['tg']}°C")
       print(f"Justifikasi     : {compound['justifikasi']}")
       print(f"Similarity      : {compound['similarity_score']:.0f} %")

# TESTING
example_smiles = "*CC(*)(F)C(=O)OCCOOCN"
result = recommend_new_compound(example_smiles)
display_results(result)

!pip freeze > requirement.txt